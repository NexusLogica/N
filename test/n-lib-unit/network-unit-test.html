<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>N Network Unit Tests</title>

  <link rel="stylesheet" href="../../app/lib/qunit/qunit.css">
  <script src="../../app/lib/qunit/qunit.js"></script>
  <script src="../../app/lib/json2.js"></script>
  <script src="../../app/lib/lodash/dist/lodash.js"></script>
  <script src="../../app/lib/random/random-0.26.js"></script>
  <script src="../../app/lib/n/n.js"></script>
  <script src="../../app/lib/n/random.js"></script>
  <script src="../../app/lib/n/signal.js"></script>
  <script src="../../app/lib/n/network.js"></script>
  <script src="../../app/lib/n/neuron.js"></script>
  <script src="../../app/lib/n/compartments.js"></script>
  <script src="../../app/lib/n/connection.js"></script>


  <script>

  var SimpleNeuronTemplate = {
    ClassName: 'N.Neuron',
    Name: 'SimpleNeuron',
    ShortName: 'SN',
    Compartments: [{
      ClassName: 'N.Comp.Output',
      Name: 'Output',
      ShortName: 'OP'
    },{
      ClassName: 'N.Comp.LinearSummingInput',
      Name: 'Input',
      ShortName: 'IP'
    },{
      ClassName: 'N.Comp.AcetylcholineInput',
      Name: 'AcetylcholineInput',
      ShortName: 'AIP'
    }]
  }

  var SourceTemplate = {
    ClassName: 'N.Neuron',
    Name: 'SourceNeuron',
    ShortName: 'SRC',
    Compartments: [{
      ClassName: 'N.Comp.OutputFromSignal',
      Name: 'Output',
      ShortName: 'OP'
    }]
  }

  QUnit.assert.near = function( actual, expected, eps, message ) {
    var hasEps = (arguments.length > 2 && typeof eps !== "string");
    var actualMessage = (hasEps ? message : eps);
    var tolerance = 1.0e-6;
    if(hasEps) {
      tolerance = eps;
    }
    var diff = Math.abs(actual-expected);
    QUnit.push(diff < tolerance, actual, expected, actualMessage);
  };

  test("Network test", function() {
    var network = new N.Network();

    equal(network.GetNumNeurons(), 0, 'No initial neurons');

    var newNeuron = new N.Neuron();
    newNeuron.Name = 'Neuron1';
    newNeuron.ShortName = 'N1';
    network.AddNeuron(newNeuron);

    equal(network.GetNumNeurons(), 1, 'One neuron');
    equal(network.GetNeuronByIndex(0).Name, 'Neuron1', "Neuron name");
    equal(network.GetNeuronByName('N1').Name, 'Neuron1', 'Neuron long name');

    newNeuron.Update = function(t) { this.UpdateCalled = true; this.Times = this.Times ? (this.Times.push(t) && this.Times) : ([ t ]);  }

    network.Update(0.1);

    equal(newNeuron.Times.length, 1, 'yes');
    equal(newNeuron.Times[0], 0.1, 'yes');

    var report = network.Validate(new N.ConfigurationReport());
    equal(report.Warnings.length, 1, "Expect one warning");
    equal(report.Errors.length, 0, "Expect no errors");
    report.WriteToLog();
  });

  test("Network with child networks test", function() {
    var childNetwork;
    var network = new N.Network();
    equal(network.GetNumNetworks(), 0, 'One network');

    var numLayerNetworks = 3;
    for(var i=0; i<numLayerNetworks; i++) {
      childNetwork = new N.Network();
      childNetwork.ShortName = 'L'+[3, 4, 6][i];
      network.AddNetwork(childNetwork);
    }
    equal(network.GetNumNetworks(), numLayerNetworks, 'Three networks');

    var childL4 = network.GetNetworkByName('L4');
    equal(network.Networks[1], childL4, 'Get L4 by name');
    equal(childL4.ParentNetwork, network, 'Get parent network');
    equal(N.FromPath(network, 'L4'), childL4, 'Get L4 by path');

    var childL6 = network.GetNetworkByName('L6');
    var numLayer6Networks = 2;
    for(i=0; i<numLayer6Networks; i++) {
      childNetwork = new N.Network();
      childNetwork.ShortName = ['a', 'b'][i];
      childL6.AddNetwork(childNetwork);
    }

    var NetworkConfig = {
      ShortName: 'C',
      RandSeed: 42,
      Templates: {
        NOutput: {
          ClassName: 'N.Neuron',
          Compartments: [{
            ClassName: 'N.Comp.OutputFromSignal',
            ShortName: 'OP',
            Initialize: function() { console.log('*** Hi - '+this.Neuron.ShortName); }
          }]
        },
        NEx: {
          Template: 'NOutput',
          Compartments: [{
            ClassName: 'N.Comp.LinearSummingInput',
            ShortName: 'IP'
          }]
        },
        NFS: {
          Template: 'NOutput',
          Compartments: [{
            ClassName: 'N.Comp.LinearSummingInput',
            ShortName: 'IP'
          }]
        },
        NInit: {
          Initialize: function() {
            this.OutputStore.AppendDataArray(N.RandConstArray({Range: [0.0, 0.5], EndTime: 0.0, Num: 5 }));
          }
        }
      },
      Networks: [{
        ShortName: 'L3',
        Neurons: [
          { ShortName: 'EX1', Template: 'NEx' },
          { ShortName: 'EX2', Template: 'NEx' }
        ]
      }, {
        ShortName: 'L4',
        Neurons: [
          { ShortName: 'SS1', Template: 'NEx' },
          { ShortName: 'SS2', Template: 'NEx' },
          { ShortName: 'SS3', Template: 'NEx' }
        ]
      }, {
        ShortName: 'L6',
        Networks: [{
          ShortName: 'a',
          Neurons: [
            { ShortName: 'NP1', Template: 'NEx' },
            { ShortName: 'NP2', Template: 'NEx' }
          ]
        }, {
          ShortName: 'b',
          Neurons: [
            { ShortName: 'IPYR1', Template: 'NEx', Data: 'First' },
            { ShortName: 'IPYR2', Template: 'NEx' }
          ]
        }]
      }],
      Connections: [
        { Path: 'L6/b:IPYR1>OP->L4:SS1>IP', Category: 'excitatory', Gain: 0.8 },
        { Path: 'L6/b:IPYR1>OP->L4:SS2>IP', Category: 'excitatory', Gain: 1.0 },
        { Path: 'L6/b:IPYR1>OP->L4:SS3>IP', Category: 'excitatory', Gain: 1.2 },
        { Path: 'L6/b:IPYR2>OP->L4:SS1>IP', Category: 'excitatory', Gain: 0.4 },
        { Path: 'L6/b:IPYR2>OP->L4:SS2>IP', Category: 'excitatory', Gain: 0.5 },
        { Path: 'L6/b:IPYR2>OP->L4:SS3>IP', Category: 'excitatory', Gain: 0.6 }
      ]
    };

    var layeredNetwork = new N.Network();
    layeredNetwork.LoadFrom(NetworkConfig);

    var first = N.FromPath(layeredNetwork, 'L6/b:IPYR1');
    ok(first, 'First exists');
    equal(first.Data, 'First', 'First has data');

    var firstOutput = first.GetCompartmentByName('OP');
    equal(firstOutput.GetNumOutputConnections(), 3, 'First num output connections');
    equal(N.FromPath(layeredNetwork, 'L6/b:IPYR2>OP').GetNumOutputConnections(), 3, 'Second num output connections');
    equal(firstOutput.GetNumInputConnections(), 0, 'First num input connections');

    equal(N.FromPath(layeredNetwork, 'L4:SS1>IP').GetNumInputConnections(), 2, 'Input is 2');
    equal(N.FromPath(layeredNetwork, 'L4:SS2>IP').GetNumInputConnections(), 2, 'Input is 2');
    equal(N.FromPath(layeredNetwork, 'L4:SS3>IP').GetNumInputConnections(), 2, 'Input is 2');


  });

  test("Network load test", function() {
    var network = new N.Network();

    var json = {
      Name: 'Layer1',
      ShortName: 'L1',
      Neurons: [{
        ClassName: 'N.Neuron', Name: 'Cajal–Retzius 1', ShortName: 'CR1'
      },{
        ClassName: 'N.Neuron', Name: 'Inhibitory Interneuron 1', ShortName: 'INB1'
      }]
    }

    network.LoadFrom(json);
    equal(network.GetNumNeurons(), 2, 'Two neurons');
    equal(network.GetNeuronByIndex(0).Name, 'Cajal–Retzius 1', "Neuron 1 name");
    equal(network.GetNeuronByName('CR1').Name, 'Cajal–Retzius 1', 'Neuron 1 long name');
    equal(network.GetNeuronByIndex(1).Name, 'Inhibitory Interneuron 1', "Neuron 2 name");
    equal(network.GetNeuronByName('INB1').Name, 'Inhibitory Interneuron 1', 'Neuron 2 long name');
  });

  test("Path object test", function() {
    N.Network.prototype.CreateTestNeuron = function(shortName, template, appendToCompartments) {
      var templateCopy = _.cloneDeep(template);
      for(var i in templateCopy.Compartments) { templateCopy.Compartments[i].ShortName += appendToCompartments; }
      this.AddTemplates({ TemplateToUse: templateCopy });
      var n = this.AddNeuron((new N.Neuron(this)).LoadFrom({ ShortName: shortName, Name: 'Long'+shortName, Template: 'TemplateToUse' }));
      return this;
    }

    var parentNetwork = (new N.Network()).LoadFrom({ShortName: "L1"}).CreateTestNeuron("L1N1", SimpleNeuronTemplate, 1);
    equal(parentNetwork.GetNeuronByName('L1N1').GetCompartmentByName('AIP1').ClassName, 'N.Comp.AcetylcholineInput', 'Compartment name');

    parentNetwork.AddNetwork((new N.Network())
        .LoadFrom({ ShortName: 'L2-1'})
        .CreateTestNeuron("L2N1", SimpleNeuronTemplate, 2)
        .CreateTestNeuron("L2N2", SimpleNeuronTemplate, 3));

    parentNetwork.AddNetwork((new N.Network())
        .LoadFrom({ ShortName: 'L2-2'})
        .CreateTestNeuron("L3N1", SimpleNeuronTemplate, 4)
        .CreateTestNeuron("L3N2", SimpleNeuronTemplate, 5));

    parentNetwork.GetNetworkByName('L2-2').AddNetwork((new N.Network())
        .LoadFrom({ ShortName: 'L3-1'})
        .CreateTestNeuron("L4N1", SimpleNeuronTemplate, 6)
        .CreateTestNeuron("L4N2", SimpleNeuronTemplate, 7));

    var target = N.FromPath(parentNetwork, ':L1N1>AIP1');
    equal(target.ClassName, 'N.Comp.AcetylcholineInput', 'Compartment name');
    equal(target.Neuron.ShortName, 'L1N1', 'Compartment\'s neuron name');

    var net = N.FromPath(parentNetwork, './L2-1');
    var target = N.FromPath(net, ':L2N1>AIP2');
    equal(target.ClassName, 'N.Comp.AcetylcholineInput', 'Compartment name');
    equal(target.Neuron.ShortName, 'L2N1', 'Compartment\'s neuron name');

    var target = N.FromPath(parentNetwork, 'L2-2:L3N2>AIP5');
    equal(target.ClassName, 'N.Comp.AcetylcholineInput', 'Compartment name');
    equal(target.ShortName, 'AIP5', 'Compartment\'s name');

    var target = N.FromPath(parentNetwork.GetNetworkByName('L2-1'), '../L2-2/L3-1:L4N1>OP6');
    equal(target.ClassName, 'N.Comp.Output', 'Compartment name');
    equal(target.ShortName, 'OP6', 'Compartment\'s name');

  });

  </script>
</head>
<body>

<div id="qunit"></div>

</body>
</html>